*******************
*MASTER EQUATE FILE
*******************
*GLOBAL VARIABLES
*
 	.GLOBL	SETUP
	.GLOBL	KILALL,GETPRC,KILL,PINIT,SUCIDE,PRCSLP,PRCDSP,PRCLSP,EXISTP
	.GLOBL	RAND,TIMER,OVERLOAD,ACTIVE,FREE,PRCSTR
	.GLOBL	SNDRES,SNDRESP,SNDPRC,ONESND,SNDLD,SNDSND,CKSNDPRI,QSNDRST
	.GLOBL	GETA11,GETA10,GETA9,GETA8,XFERPROC
	.GLOBL	PUTA11,PUTA10,PUTA9,PUTA8,XFERPROC
	.GLOBAL	L_TIMER

*GLOBALS TO NARC MAIN
	.GLOBAL	ERRORLOG
*
*PROCESS DATA STRUCTURE
*NOTE: MAKE SURE THIS IS EVENLY DIVISIBLE BY 32
PLINK	.SET	0	;LINK TO NEXT 32 BITS
PROCID	.SET	20H	;PROCESS ID 16 BITS
PTIME	.SET    30H	;SLEEP TIME X 16MSEC 16 BITS
PSPTR	.SET    40H	;PROCESS STACK POINTER 32 BITS
PDATA	.SET    60H	;PROCESS DATA STORE
PSDATA	.SET   2A0H     ;PROCESS STACK DATA (PC, A8-A11)
PRCSIZ	.SET   5A0H     ;END OF DATA STRUCTURE
NPROC	.SET   168	;NUMBER OF PROCESSES

SLPSTCK	.SET   0A0H	;# OF WORDS PUSHED ON PROCESS STACK FOR SLEEPS
*
*GSP MACROS
*
*
*SUBTRACT REGISTER FROM MEMORY
*	SUBRM	REG,ADDR,FIELD SIZE
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY
*
SUBRM	$MACRO	P1,P2,P3
	MOVE	:P2:,A14,:P3:
	SUB	:P1:,A14
	MOVE	A14,:P2:,:P3:
	$ENDM
*
*ADD REGISTER TO MEMORY
*	ADDRM	REG,ADDR,FIELD SIZE
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY
*
ADDRM	$MACRO	P1,P2,P3
	MOVE	:P2:,A14,:P3:
	ADD	:P1:,A14
	MOVE	A14,:P2:,:P3:
	$ENDM

*INCREMENT LOCATION
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY
**
INCW	$MACRO	P1
	MOVE	:P1:,A14
	INC	A14
	MOVE	A14,:P1:
	$ENDM

*
*DECREMENT WORD
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY
**
DECW	$MACRO	P1
	MOVE	:P1:,A14
	DEC	A14
	MOVE	A14,:P1:
	$ENDM

*
*SUBTRACT MEMORY
*	SUBM	ADDR,REG,FIELD SIZE
*SUBTRACTS ADDRESS FROM REGISTER
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY
*
SUBM	$MACRO	P1,P2,P3
	MOVE	:P1:,A14,:P3:
	SUB	A14,:P2:
	$ENDM
*
*ADD MEMORY
*	ADDM	ADDR,REG,FIELD SIZE
*ADDS ADDRESS FROM REGISTER
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY
*
ADDM	$MACRO	P1,P2,P3
	MOVE	:P1:,A14,:P3:
	ADD	A14,:P2:
	$ENDM
*
*NEGATE MEMORY
*	NEGM	ADDR,FIELD SIZE
*NEGATES ADDRESS CONTENTS
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY
*
NEGM	$MACRO	P1,P2
	MOVE	:P1:,A14,:P2:
	NEG	A14
	MOVE	A14,:P1:,:P2:
	$ENDM
*
*COMPARE MEMORY
*	CMPM	ADDR,REG,FIELD SIZE
*COMPARES ADDRESS TO REGISTER
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY
*
CMPM	$MACRO	P1,P2,P3
	MOVE	:P1:,A14,:P3:
	CMP	A14,:P2:
	$ENDM
*
*CLEAR MEMORY
*	CLRM	ADDR,FIELD SIZE
*CLEARS ADDRESS CONTENTS
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY
*
CLRM	$MACRO	P1,P2
	CLR	A14
	MOVE	A14,:P1:,:P2:
	$ENDM
*
*COMPLEMENT MEMORY
*	COMM	ADDR,FIELD SIZE
*COMPLEMENTS ADDRESS CONTENTS
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY
*
COMM	$MACRO	P1,P2
	MOVE	:P1:,A14,:P2:
	NOT	A14
	MOVE	A14,:P1:,:P2:
	$ENDM
*
*SHIFT LEFT MEMORY
*	SLLM	SHIFT COUNT,ADDR,FIELD SIZE
*SHIFTS ADDRESS CONTENTS
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY
*
SLLM	$MACRO	P1,P2,P3
	MOVE	:P2:,A14,:P3:
	SLL	:P1:,A14
	MOVE	A14,:P2:,:P3:
	$ENDM
*
*SHIFT RIGHT ARITHMETIC MEMORY
*	SRAM	SHIFT COUNT,ADDR,FIELD SIZE
*SHIFTS ADDRESS CONTENTS
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY
*
SRAM	$MACRO	P1,P2,P3
	MOVE	:P2:,A14,:P3:
	SEXT	A14,:P3:
	SRA	:P1:,A14
	MOVE	A14,:P2:,:P3:
	$ENDM
*
*SHIFT RIGHT LOGICAL MEMORY
*	SRLM	SHIFT COUNT,ADDR,FIELD SIZE
*SHIFTS ADDRESS CONTENTS
*A14 DESTROYED, 'A' REGISTER TYPE INSTRUCTIONS ONLY
*
SRLM	$MACRO	P1,P2,P3
	MOVE	:P2:,A14,:P3:
	ZEXT 	A14,:P3:
	SRL	:P1:,A14
	MOVE	A14,:P2:,:P3:
	$ENDM
*
*PROCESS SLEEP CONSTANT
*P1=SLEEP TIME CONSTANT 1-FFFF LOADED INTO A0
*RET ADDR ON STACK
*
SLEEP	$MACRO	P1
	$IF	P1 < 33
	MOVK	:P1:,A0
	$ELSE	
	MOVI	:P1:,A0
	$ENDIF
	CALLA	PRCSLP
	$ENDM
*
*PROCESS SLEEP REGISTER
*REG1=REGISTER THAT CONTAINS SLEEP TIME 1-FFFF LOADED INTO A0
*RET ADDR ON STACK
*
SLEEPR	$MACRO	REG1
	MOVE	:REG1:,A0
	CALLA	PRCSLP
	$ENDM

*
*PROCESS LOOP SLEEP
*P1=SLEEP TIME -->A0, P2 =WAKEUP ADDR-->A7
*
SLOOP	$MACRO	P1,P2
	$IF	P1 < 33
	MOVK	:P1:,A0
	$ELSE	
	MOVI	:P1:,A0
	$ENDIF
	MOVI	:P2:,A7,L
	JAUC	PRCLSP
	$ENDM
	
*
*PROCESS LOOP SLEEP REGISTER
*P1=REGISTER CONTAINING SLEEP TIME 1-FFFF, P2 =WAKEUP ADDR-->A7
*
SLOOPR	$MACRO	P1,P2
	MOVE	:P1:,A0
	MOVI	:P2:,A7,L
	JAUC	PRCLSP
	$ENDM

*
*PROCESS CREATION MACRO
*P1=ID-->A1, P2=PC-->A7
*
CREATE	$MACRO	P1,P2
 	MOVI	:P1:,A1
	MOVI	:P2:,A7,L
	CALLA	GETPRC
	$ENDM

*
*KILL PROCESS(ES)
*P1=ID-->A0,P2=MASK-->A1
*
KILLIT	$MACRO	P1,P2
	MOVI	:P1:,A0
	MOVI	:P2:,A1
	CALLA	KILALL
	$ENDM

*
*CALL IT QUITS
*
DIE	$MACRO
	JAUC	SUCIDE
	$ENDM
*
*PROCESS JUMP SUBROUTINE
*P1=ADDRESS OF SLEEPING PROCESS
*A7 IS USED FOR PC STORAGE
*
JSRP	$MACRO	P1
	GETPC	A7
	ADDI    060h,A7
	MOVE	A7,-*A12,L	;PUSH RET ADDR
	JAUC	:P1:
	$ENDM

*
*PROCESS JUMP SUBROUTINE ON REGISTER
*R1=REGISTER CONTAINING ADDRESS OF SLEEPING PROCESS
*A7 IS USED FOR PC STORAGE
*
JSRPR	$MACRO	R1
	GETPC	A7
	ADDI    040h,A7
	MOVE	A7,-*A12,L	;PUSH RET ADDR
	JUMP	:R1:
	$ENDM

*
*RETURN FROM SLEEPING SUBROUTINE
*A7 IS USED FOR PC STORAGE
*STATUS REGISTER IS NOT AFFECTED
*	
RETP	$MACRO	
	MMFM	A12,A7		;PULL RETURN ADDR, W/O ZAPPING STAT
	EXGPC	A7
	$ENDM

*FIND MATCHING PROCESS(ES), BRANCH IF ONE WAS FOUND
*P1=ID-->A0,P2=MASK-->A1,P3=BRANCH LABEL
MATCHP	$MACRO	P1,P2,P3
	MOVI	:P1:,A0
	MOVI	:P2:,A1
	CALLA	EXISTP
	JANZ	:P3:
	$ENDM

*FIND MATCHING PROCESS(ES), BRANCH IF NONE WERE FOUND
*P1=ID-->A0,P2=MASK-->A1,P3=BRANCH LABEL
NOMATCHP $MACRO	P1,P2,P3
	 MOVI	:P1:,A0
	 MOVI	:P2:,A1
	 CALLA	EXISTP
	 JAZ	:P3:
	 $ENDM

*PUSH REGISTER(S) ONTO THE STACK
*USAGE: ONE OPERAND -> PUSH OP   2 OR MORE OPS -> PUSH (OP1,OP2,...,OPN)
PUSH	$MACRO	REG
	MOVE :REG:,-*SP,1
	$ENDM

*PULL REGISTER(S) OFF OF THE STACK
*USAGE: ONE REGISTER -> PULL REG   2 OR MORE REGS -> PULL (REG1,REG2,...,REGN)
PULL	$MACRO	REG
	MMFM	SP,:REG:
	$ENDM

*PUSH REGISTER ONTO THE PROCESS STACK
*USAGE: ONE OPERAND -> PUSH REG
PUSHP	$MACRO	REG
	MOVE :REG:,-*A12,L
	$ENDM

*PULL REGISTER(S) OFF OF THE PROCESS STACK
*USAGE: ONE REGISTER -> PULL REG 
PULLP	$MACRO	REG
	MMFM	A12,:REG:
	$ENDM

*PUSH LOW WORD OF REGISTER ON TO STACK
*ONE REGISTER ONLY!
*USAGE: PUSHW REG
PUSHW	$MACRO	REG
	MOVE :REG:,-*SP,0
	$ENDM

*PULL LOW WORD OF REGISTER OFF OF STACK
*ONE REGISTER ONLY!
*USAGE: PULLW REG
PULLW	$MACRO	REG
	MOVE *SP+,:REG:,0
	$ENDM

*MAKE A SINGLE SOUND USING THE GSP SOUND PROCESSOR
SOUND1	$MACRO SNDNUM
	MOVI :SNDNUM:,A0
	CALLA ONESND
	$ENDM

*NULL LONG WORD							 
LONGNULL:$MACRO	 
	.LONG 0								 
	$ENDM								 

*
*CALLERR - CALL THE ERROR LOG MACRO
*REGS = # OF REGISTERS PUSHED ON THE STACK BY THIS SUBROUTINE
CALLERR	$MACRO	REGS
	MOVE	A1,-*SP,L	
	MOVE	*SP((:REGS:+1)*20H),A1,L
	CALLA	ERRORLOG	
	MMFM	SP,A1
	$ENDM
*
*CALLERR1 - CALL THE ERROR LOG MACRO TYPE 1
*REGS = # OF REGISTERS PUSHED ON THE STACK BY THIS SUBROUTINE
CALLERR1 $MACRO	REGS
	MOVE	A1,-*SP,L	
	MOVE	*SP((:REGS:+1)*20H),A1,L
	CALLA	ERRLOG1	
	MMFM	SP,A1
	$ENDM

*
*CALLERR2 - CALL THE ERROR LOG MACRO TYPE 2
*REGS = # OF REGISTERS PUSHED ON THE STACK BY THIS SUBROUTINE
CALLERR2 $MACRO	REGS
	MOVE	A1,-*SP,L	
	MOVE	*SP((:REGS:+1)*20H),A1,L
	CALLA	ERRLOG2	
	MMFM	SP,A1
	$ENDM
